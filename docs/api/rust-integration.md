# Rust Integration API Reference

ZBuild provides a comprehensive API for integrating Rust crates into Zig projects with automatic FFI generation, cross-compilation, and seamless linking.

## Core API Functions

### `addRustCrate()`

Add a Rust crate to your ZBuild project with full configuration options.

```zig
pub fn addRustCrate(self: *Builder, options: struct {
    name: []const u8,
    path: []const u8,
    crate_type: RustCrate.CrateType = .cdylib,
    features: []const []const u8 = &[_][]const u8{},
    target: ?std.Target = null,
    optimize: RustCrate.OptimizeMode = .ReleaseFast,
    cross_compile: ?struct {
        rust_target: []const u8,
        linker: ?[]const u8 = null,
        sysroot: ?[]const u8 = null,
    } = null,
}) !*RustCrate
```

#### Parameters

| Parameter | Type | Description | Default |
|-----------|------|-------------|---------|
| `name` | `[]const u8` | **Required.** Crate name (must match Cargo.toml) | - |
| `path` | `[]const u8` | **Required.** Path to crate directory | - |
| `crate_type` | `CrateType` | Output artifact type | `.cdylib` |
| `features` | `[]const []const u8` | Cargo features to enable | `{}` |
| `target` | `?std.Target` | Zig target for builds | `null` |
| `optimize` | `OptimizeMode` | Optimization level | `.ReleaseFast` |
| `cross_compile` | Cross-compilation config | See [Cross-Compilation](#cross-compilation) | `null` |

#### CrateType Options

```zig
pub const CrateType = enum {
    bin,        // Executable binary
    lib,        // Rust library (rlib)
    rlib,       // Rust library
    dylib,      // Dynamic library (.so, .dylib, .dll)
    cdylib,     // C-compatible dynamic library (recommended for FFI)
    staticlib,  // Static library (.a, .lib)
    proc_macro, // Procedural macro
};
```

#### OptimizeMode Options

```zig
pub const OptimizeMode = enum {
    Debug,        // Debug build (fast compile, slow runtime)
    ReleaseSafe,  // Optimized with safety checks
    ReleaseFast,  // Maximum optimization (recommended)
    ReleaseSmall, // Optimize for binary size
};
```

#### Example Usage

```zig
// Basic usage
const my_crate = try b.addRustCrate(.{
    .name = "my-crate",
    .path = "crates/my-crate",
});

// Advanced configuration
const ai_engine = try b.addRustCrate(.{
    .name = "ai-engine",
    .path = "crates/ai-engine",
    .crate_type = .cdylib,
    .features = &[_][]const u8{ "ffi", "optimized", "gpu" },
    .optimize = .ReleaseFast,
    .cross_compile = .{
        .rust_target = "aarch64-apple-darwin",
        .linker = "clang",
        .sysroot = "/Applications/Xcode.app/Contents/Developer/SDKs/MacOSX.sdk",
    },
});
```

### `generateHeaders()`

Generate C headers for Rust FFI using cbindgen.

```zig
pub fn generateHeaders(self: *Builder, crate: *RustCrate, options: struct {
    output_dir: []const u8,
    header_name: []const u8,
    include_guard: ?[]const u8 = null,
}) !void
```

#### Parameters

| Parameter | Type | Description | Default |
|-----------|------|-------------|---------|
| `crate` | `*RustCrate` | **Required.** Rust crate (from `addRustCrate()`) | - |
| `output_dir` | `[]const u8` | **Required.** Directory for generated headers | - |
| `header_name` | `[]const u8` | **Required.** Header file name | - |
| `include_guard` | `?[]const u8` | C header include guard name | Auto-generated |

#### Example Usage

```zig
const my_crate = try b.addRustCrate(.{
    .name = "my-crate",
    .path = "crates/my-crate",
    .crate_type = .cdylib,
});

try b.generateHeaders(my_crate, .{
    .output_dir = "include/",
    .header_name = "my_crate.h",
    .include_guard = "MY_CRATE_H",
});
```

#### Generated Header Example

```c
/* Auto-generated by cbindgen */
#ifndef MY_CRATE_H
#define MY_CRATE_H

#include <stdint.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

int32_t my_crate_add(int32_t a, int32_t b);
void my_crate_free_string(char *s);

#ifdef __cplusplus
}
#endif

#endif /* MY_CRATE_H */
```

### `linkRustCrate()`

Link a Rust crate to a Zig executable (used internally by ZBuild).

```zig
pub fn linkRustCrate(self: *Builder, executable: anytype, rust_crate: *RustCrate) !void
```

#### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `executable` | `anytype` | Zig executable target |
| `rust_crate` | `*RustCrate` | Rust crate to link |

#### Example Usage

```zig
const my_crate = try b.addRustCrate(.{
    .name = "my-crate",
    .path = "crates/my-crate",
});

const my_exe = b.addExecutable(.{
    .name = "my-app",
    .root_source_file = "src/main.zig",
});

try b.linkRustCrate(my_exe, my_crate);
```

## Cross-Compilation

### `buildForTargets()`

Build Rust crates for multiple targets in a single command.

```zig
pub fn buildForTargets(self: *Builder, targets: []const std.Target) !void
```

#### Example Usage

```zig
const targets = &[_]std.Target{
    .{ .cpu = .x86_64, .os = .linux, .abi = .gnu },
    .{ .cpu = .aarch64, .os = .macos, .abi = .none },
    .{ .cpu = .x86_64, .os = .windows, .abi = .msvc },
};

try b.buildForTargets(targets);
```

### `zigTargetToRustTarget()`

Convert Zig targets to Rust target triples.

```zig
pub fn zigTargetToRustTarget(self: *Builder, target: std.Target) ![]const u8
```

#### Example Usage

```zig
const zig_target = std.Target{
    .cpu = .x86_64,
    .os = .linux,
    .abi = .gnu,
};

const rust_target = try b.zigTargetToRustTarget(zig_target);
// Result: "x86_64-unknown-linux-gnu"
defer b.allocator.free(rust_target);
```

## Advanced Features

### Cross-Compilation Configuration

```zig
.cross_compile = .{
    .rust_target = "aarch64-apple-darwin",     // Rust target triple
    .linker = "clang",                         // Custom linker
    .sysroot = "/path/to/sdk",                 // Custom sysroot
}
```

#### Environment Variables

ZBuild automatically sets these environment variables for cross-compilation:

- `CARGO_TARGET_{TARGET}_LINKER` - Custom linker for target
- `CARGO_TARGET_{TARGET}_RUSTFLAGS` - Additional Rust flags (sysroot, etc.)

#### Supported Target Triples

| Platform | Architecture | Target Triple |
|----------|-------------|---------------|
| **Linux** | x86_64 | `x86_64-unknown-linux-gnu` |
| **Linux** | ARM64 | `aarch64-unknown-linux-gnu` |
| **Linux** | x86_64 (musl) | `x86_64-unknown-linux-musl` |
| **macOS** | x86_64 | `x86_64-apple-darwin` |
| **macOS** | ARM64 | `aarch64-apple-darwin` |
| **Windows** | x86_64 | `x86_64-pc-windows-msvc` |
| **Windows** | x86_64 (GNU) | `x86_64-pc-windows-gnu` |
| **FreeBSD** | x86_64 | `x86_64-unknown-freebsd` |
| **WebAssembly** | wasm32 | `wasm32-wasi` |

## Integration with Zig Code

### Using Generated Headers

```zig
const std = @import("std");

// Import generated FFI headers
const c = @cImport({
    @cInclude("include/my_crate.h");
});

pub fn main() !void {
    // Call Rust functions from Zig
    const result = c.my_crate_add(10, 20);
    std.debug.print("Result: {d}\n", .{result});
}
```

### Memory Management

```zig
// Rust function that returns owned string
const c_string = c.my_crate_get_message();
defer c.my_crate_free_string(c_string);

// Convert to Zig string
const zig_string = std.mem.span(c_string);
std.debug.print("Message: {s}\n", .{zig_string});
```

### Error Handling

```zig
// Rust function that can fail
const result = c.my_crate_parse_json(json_str);
if (result.error_code != 0) {
    std.debug.print("Error: {s}\n", .{std.mem.span(result.error_message)});
    c.my_crate_free_string(result.error_message);
    return;
}

// Use successful result
defer c.my_crate_free_result(result);
// ... use result.data
```

## Best Practices

### 1. FFI Function Naming

Use consistent prefixes for all exported functions:

```rust
// Rust side
#[no_mangle]
pub extern "C" fn mylib_create() -> *mut MyStruct { /* ... */ }

#[no_mangle]
pub extern "C" fn mylib_destroy(ptr: *mut MyStruct) { /* ... */ }

#[no_mangle]
pub extern "C" fn mylib_process(ptr: *mut MyStruct, data: *const u8) -> i32 { /* ... */ }
```

### 2. Memory Management

Always provide cleanup functions:

```rust
#[no_mangle]
pub extern "C" fn mylib_free_string(s: *mut c_char) {
    if !s.is_null() {
        unsafe { let _ = CString::from_raw(s); }
    }
}
```

### 3. Error Handling

Use result structures for complex error handling:

```rust
#[repr(C)]
pub struct MyResult {
    pub success: bool,
    pub error_code: i32,
    pub error_message: *mut c_char,
    pub data: *mut MyData,
}

#[no_mangle]
pub extern "C" fn mylib_operation() -> MyResult {
    // ... implementation
}
```

### 4. Feature Flags

Organize FFI exports behind feature flags:

```toml
[features]
default = []
ffi = []
gpu = []
```

```rust
#[cfg(feature = "ffi")]
pub mod ffi {
    // FFI exports here
}
```

## Common Patterns

### JSON Data Exchange

```rust
// Rust side
#[no_mangle]
pub extern "C" fn mylib_process_json(
    json_input: *const c_char
) -> *mut c_char {
    let input = unsafe { CStr::from_ptr(json_input) }.to_str().unwrap();
    let data: InputData = serde_json::from_str(input).unwrap();

    let result = process_data(data);
    let output = serde_json::to_string(&result).unwrap();

    CString::new(output).unwrap().into_raw()
}
```

```zig
// Zig side
const input = .{ .name = "test", .value = 42 };
const json_input = try std.json.stringifyAlloc(allocator, input, .{});
defer allocator.free(json_input);

const c_input = try allocator.dupeZ(u8, json_input);
defer allocator.free(c_input);

const c_result = c.mylib_process_json(c_input.ptr);
defer c.mylib_free_string(c_result);

const result_json = std.mem.span(c_result);
const result = try std.json.parseFromSlice(ResultData, allocator, result_json, .{});
defer result.deinit();
```

This API provides everything needed for seamless Rust-Zig integration with ZBuild!